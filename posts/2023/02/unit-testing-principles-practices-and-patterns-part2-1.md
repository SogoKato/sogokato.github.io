---
title: "リファクタリングしやすいテストを書こう：単体テストの考え方／使い方 第2部前半"
date: "2023-02-04"
tags: ["単体テスト", "読書"]
---

[『単体テストの考え方／使い方』（Vladimir Khorikov 著、須田智之訳）](https://book.mynavi.jp/ec/products/detail/id=134252)を読んでいるので、そのまとめを部ごとに書いていこうと思います。

今回は第2部「単体テストとその価値」の前半についてのまとめになります。第2部は以下の4章で構成されています。今回は前半の第4章と第5章について扱います。

* **第4章：良い単体テストを構成する4本の柱**
* **第5章：モックの利用とテストの壊れやすさ**
* 第6章：単体テストの3つの手法
* 第7章：単体テストの価値を高めるリファクタリング

まず、各章の内容の要約（切り抜き）を書き、その後に考察してみたいと思います。

---

## 第4章：良い単体テストを構成する4本の柱

* 4本の柱（p.96）
  * **退行（regression）に対する保護**
  * **リファクタリングへの耐性**
  * **迅速なフィードバック**
  * **保守のしやすさ**
* 1本目の柱：退行（regression）に対する保護（pp.96-98）
  * ソフトウェアで発生する退行とはバグのこと
  * 退行に対する保護がテストにどのくらい備わっているかを把握するには、次のことに目を向けるようにします
    * テスト時に実行されるプロダクション・コードの量
      * 量が増えると、退行が見つかる可能性は高くなります
    * そのコードの複雑さ・そのコードが扱っているドメインの重要性
      * **複雑なビジネス・ロジックが記述されたコードはボイラープレート・コードよりもはるかに重要**
      * ビジネス的に重要な機能になるほど、持ち込まれたバグによって生じる被害もおおきくなる
  * さらに、退行が発生することを回避するには……**ライブラリやフレームワークなどの外部から持ち込んだコード**のことも考慮しなくてはなりません
    * アプリケーションのために書かれたコードと同じくらい、機能に影響を与える
    * **テストの際にできるだけ多くのプロダクション・コードを実行させるようにします**
* 2本目の柱：リファクタリングへの耐性（pp.98-99）
  * リファクタリングとは、既存のコードの観測可能な振る舞い（observable behavior）を変えることなく、そのコードを変更すること
  * **リファクタリングを行った結果**……**テストが失敗するようになった**……このテストはテスト対象の機能が正しく振る舞っていることを検証していたわけではなかったのです。**このようなテストの失敗のことを偽陽性（false positive）と呼びます**
  * （リファクタリングへの耐性が備わっていれば）次の2つの効果が得られるようになります
    * 既存の機能に何らかの問題を持ち込んでしまった場合、テストによってそのことが早い段階で警告されるようになる
    * プロダクション・コードを変更しても退行が起こらないことに自信を持てるようになる
* 何が偽陽性（false positive）を引き起こすのか？（p.101）
  * テスト・コードがプロダクション・コードとより密接に結びついてしまうと、より多くの嘘の警告が発せられることになる
    * **検証する対象を観察可能な振る舞いとし、その結果を得るための細かい手順である実装の詳細には目を向けない**
  * もっとも意識すべきことは、作成するテスト・ケースが問題領域に関する物語（story）を伝えているのか、ということ
    * そのような意識でテスト・ケースが作成されていれば……テスト・ケースで語られれている物語と実際のアプリケーションの振る舞いとのあいだに違いがあることが明らかになります
* **観測可能な振る舞いを検証するようなテスト・ケースは偽陽性を生み出すことは**（仮にあったとしても）**滅多にありません**（pp.107-108）
  * なぜ……「まったくない」のではなく「滅多にない」なのか……その理由は……テスト・ケースが壊れてしまう可能性はまだあるからです
  * たとえば……新たな引数を追加した場合、コンパイル・エラーが発生します
  * とはいえ、この種の偽陽性は簡単に修正できます……エラー・メッセージに従って……新たな引数を追加するだけ
  * 一方、コンパイル・エラーが発生しない偽陽性の対処は簡単ではありません……本当のバグとの区別がつけにくく、調査をするのにより多くの時間を要することになる
* **最初の2本の柱**……を備えることはテスト・スイートの正確性を最大限に引き上げることになる（p.110）
  * **テストをすることでどのくらいのバグを検出できるのか？**
    * 偽陰性（見つけられないバグ）の発生を抑える……大綱に対する保護がこの性質に該当
  * **テストをすることでバグがないことをどのくらい示せるのか？**
    * 偽陽性（嘘の警告）の発生を抑えることに関係し、リファクタリングへの耐性がこの性質に該当
* 3本目の柱：迅速なフィードバック（p.113）
  * **テストを速やかに行えるようになると、フィードバックを得てから改善するまでの時間も劇的に短くなり**……**バグがすぐに検出されるようになります**
  * テストが遅くなると、テストを実施する回数が減ってしまい、開発が間違った方向に進んでしまっても気づくまでに時間がかかる
* 4本目の柱：保守のしやすさ（p.113）
  * **保守コストの評価**となる性質
  * 次の2つの観点から把握できます
    * **テスト・ケースを理解することがどのくらい難しいのか？**
    * **テストを行うことがどのくらい難しいのか？**
* 退行に対する保護、リファクタリングへの耐性、迅速なフィードバックの3本の柱は互いに背反する性質（p.115）
  * **4本の柱のうち1本でもテスト・ケースに備わっていなければ……そのテスト・ケースの価値はなくなってしまう**
  * すべての柱を可能な限り備えるように努めなくてはなりません
* 極端な例 #1: **E2E（End-to-End）テスト**（pp.115-116）
  * E2Eテストでは、多くのプロダクション・コードが実行されることになるため、退行に対する保護を十分に備えている
  * 加えて、E2Eテストは嘘の警告を発する偽陽性（false positive）も持ち込まれにくいため、リファクタリングへの耐性が最も備わった種類のテストである
  * 大きな欠点……**テストを実行し終えるまでに時間がかかってしまう**こと
  * E2Eテストだけでコードベースを管理することが現実的でないことの理由
* 極端な例: #2: 取るに足らないテスト（p.117）
  * プロダクション・コードと同じことを別の書き方で表現しているだけであり、常に成功する
  * 退行に対する保護は全く備わっていない
* 極端な例: #3: 壊れやすいテスト（pp.118-119）
  * 何（what）ではなくどのように（how）ということに目を向けているため……リファクタリングを妨げるものとなってしまった
* どのようなトレード・オフを図ればよいのでしょうか？（p.121）
  * 現実において、リファクタリングへの耐性を犠牲にすることはできません
  * **退行に対する保護を優先するのか、それとも、迅速なフィードバックを優先するのか、ということを選択することを要求されるようになる**
* E2Eテストだと退行に対する保護のほうが重要になり、単体テストだと迅速なフィードバックのほうが重要になる。一方、統合テストはそれらの真ん中くらいの割合が最善のバランスになる（p.125）
  * ここで注目してほしいのが、どの層もリファクタリングへの耐性を必ず備えるようにしている点です
  * ![fig 4.12](//www.plantuml.com/plantuml/png/LP3DIiD058NtUOfPraKsNOjqqwSmBiRajWRh59BfVdvGKbG8Y611aQ9Gg6WL4HMYUPZRr6JLLt2Q22QB6MQutptdS3eXfm4V7Gsi5kevwajKKrGBL6dvVKNrZF83vLCkufMOEMoTHAjhaTtFYacCyW7b1DNfEXbl4HgI07hKvSF0QXL2vDCp0pWiMtnNr3AzoH_V_y1-067e3vdLojFZGjoYd3kizBz3dQ0UeuvHQvEbNEW1UFlKFRG2S3bb_G6GRhkB-WJL9-feWq0RQjEVjvSiZXg0pxYnfTouri3i_6hvTT40Hypdrdz4icsNukOGkw5IUnExMjjSnDwf1wuw8VRkWUzvmFQQ6XrWdkd_5m00)

---

## 第5章：モックの利用とテストの壊れやすさ

* テスト・ダブルには……5種類があります……モックとスタブの2つに大きく分けることができます（pp.132-134）
  * **モック**：モック、スパイ
    * テスト対象システムからその依存に向かって行われる**外部に向かうコミュニケーション（出力）を模倣**し、そして、**検証する**
    * スパイはモックと同じ役割を担う
      * モックはモック・フレームワークの助けを借りて生成される
      * スパイは開発者自身の手で実装される
  * **スタブ**：スタブ、ダミー、フェイク
    * 依存からテスト対象システムに向かって行われる**内部に向かうコミュニケーション（入力）を模倣**
    * ダミーとは、null値や一時しのぎで使われる文字列などのシンプルなハード・コーディングされた値のこと
    * スタブはもっと洗練されており、設定によって返す結果を異なるシナリオごとに変えられる完全に自立した依存として振る舞うもの
    * フェイクと使う目的はスタブの場合とほぼ同じである一方、通常、フェイクはまだ存在しない依存を置き換えるために作成される
* **スタブとのやりとりを決して検証してはならない**（pp.135-137）
  * スタブが行っていることは、テスト対象システムが最終的な結果を生成するのに必要なデータを提供する、ということだけ
  * **最終的な結果の一部とはならないものを検証することを過剰検証（over-specification）と呼びます**
* すべてのプロダクション・コードは次の2つの観点で分類できます（pp.140-141）
  * 公開されたAPIなのか、それとも、プライベートなAPIなのか？
  * **観測可能な振る舞いなのか、それとも、実装の詳細なのか？**
    * 観測可能な振る舞い（observable behavior）の一部になるには、そのコードは次に挙げるもののどちらかでなくてはなりません
      * クライアントが目標を達成するために使う公開された操作
      * クライアントが目標を達成するために使う公開された状態
* クライアントが1つの目標を達成するのにテスト対象となるクラスが提供する複数のメソッドを呼び出す必要があるのであれば、そのクラスは実装の詳細を漏洩していると見た方がよいでしょう。理想とすべきAPIの設計は、いかなる目標であれ、1つの操作で目標を達成できるようにすることです（p.146）
* **アプリケーション・サービスに対するテスト・ケースはビジネスにおける全体的なユースケースがいかに実行されるのかを検証する**のに対し、**ドメイン・クラスに対するテスト・ケースは同じユース・ケースが完了に至るまでの一部を検証する**ことになる（p.153）
  * ![fig 5.10](//www.plantuml.com/plantuml/png/SoWkIImgAStDuIfAJIv9p4lFILLGUhfasilc5O-RrZzkNlcuQSdZfaMFcpS_RkvGKaWiLaZEoKpDAq5M3fQV_hXvrUEcZO-RzpnkslwuUJbOn-x7JLj18isJ7pVj1EikJYqgoqnEHT7UtFcuUI7G7eWMcBKx3S4QKl9p4pFp38dHO8IamOWBuau5tPJyyZnTEvZ52bOAIizdhtksOkRxFHsFcvU1tRiJRCf62FlzdaubBfXgtT82e5weKJ1Hc9amjo7CVDouxicE1c3OAN51vQ0cG7NYCC48Zmb6Q2OufEQb0ACB0000)
* システム内コミュニケーションとシステム間コミュニケーション（pp.155-156）
  * **システム内コミュニケーションは実装の詳細になります**。その理由は、クライアントからのリクエストを処理する際、ドメイン・クラス間で行われるやり取りは観測可能な振る舞いの一部にはならないからです
  * システム間コミュニケーションの場合は違います。なぜなら、テスト対象のアプリケーションがどのように外部とのコミュニケーションを取るのか、ということはそのシステムの観測可能な振る舞い全体を形成するものだからです
* **外部から観察できないプロセス外依存とのコミュニケーションは実装の詳細になる**（pp.163-164）
  * もし、データベースに対してテスト対象のアプリケーションを除くすべてのアプリケーションからアクセスされることが決してないのであれば、テスト対象のアプリケーションとデータベースのコミュニケーションに関する仕様を（既存の機能を破綻させない限り）好きなように変えられることになります
  * **しかしながら、このことは明らかに課題を抱えることになります**……迅速なフィードバックを得られなくなってしまうからです（→6・7章）

---

## 感想と考察

ここからは本を読みながら、私が思ったことや考えたことを書きます。

### リファクタリングへの耐性を持つことが常に必要

今回読んだ範囲では「良い単体テストを構成する4本の柱」について説明されていましたが、その中でも一貫して重要視されていたのが2本目の柱「リファクタリングへの耐性」です。

リファクタリングへの耐性を持たせるためのコツは「観測可能な振る舞い」のみをテストし、それを得るまでの過程は見ないということです（how ではなく what をみる）。そのため E2E テストは退行に対する保護を最大限に備えていると言えます。私が所属するチームでも E2E テストのことを普段「リグレッション・テスト」と呼んでおり、その通りだなと思いました。

一方で E2E テストには実行時間が長くかかってしまうので、E2E テストだけで開発を行うのは厳しいです。しかしながら、筆者は第5章で「システム内コミュニケーションは実装の詳細になります」と言い、観測可能な振る舞いではない（テストで見るべき最終的な結果ではない）としています。そうなるとほとんどやっていることは E2E テストと同じなので単体テストの範疇ではない気がします。これは明らかな矛盾ですが、ここについては第6・7章で説明してくれるようなので続きを楽しみにしたいと思います。

また、単体テストがカバーする範囲を広くしすぎると p-r をレビューする時に、対象のコードが問題ないかの判断をするのが難しくなるのではないかな？という疑問点が浮かんできました。テスト粒度のバランスについても以降の章で説明があるのを期待しています。

### モックとスタブ

モックに関連して5つの用語が出てきました。モック・スパイ・スタブ・ダミー・フェイクです。正直、これらの役割のものは全部モックだと思っていました。言葉の意味を知ったからには意識して使い分けていこうと思います。

ここで重要だと思ったのは「スタブとのやりとりを決して検証してはならない」という点です。

リファクタリングへの耐性の話でも出てきたように、観測可能な振る舞いのみをテストするべきとうことと一貫して、テスト対象システムが持ってくる値を検証することは、テスト対象システムの実装の詳細（how）を調べることになり、過剰検証となります。

今まで実装してきた単体テストを思い返してみて、これをやってしまっていることはあまりないとは思いますが、うっかりするとやってしまいそうなので意識していきたいです。

## まとめ

以上、第2部「単体テストとその価値」の前半についてのまとめと所感を拙文ながら書きました。気づきが多いので、自分が携わるコードでもこの本で得た知識を導入しようと試みています。早く全部読み切らなきゃ。ではでは。
