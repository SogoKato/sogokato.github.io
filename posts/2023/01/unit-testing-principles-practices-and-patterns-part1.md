---
title: "単体テストの目的・定義・学派・命名について：単体テストの考え方／使い方 第1部"
date: "2023-01-17"
tags: ["単体テスト", "読書"]
---

[『単体テストの考え方／使い方』（Vladimir Khorikov 著、須田智之訳）](https://book.mynavi.jp/ec/products/detail/id=134252)を読んでいるので、そのまとめを部ごとに書いていこうと思います。

今回は第1部「単体（unit）テストとは」についてのまとめになります。第1部は以下の3章で構成されています。

* 第1章：なぜ、単体（unit）テストを行うのか？
* 第2章：単体テストとは何か？
* 第3章：単体テストの構造的解析

まず、各章の内容の要約（切り抜き）を書き、その後に考察してみたいと思います。

---

## 第1章：なぜ、単体（unit）テストを行うのか？

* テストの質が悪ければ、テストをまったくしない場合と同じ結果になる（p.8）
* **テスト・ケースは多いほど良い……は間違いです。なぜなら、コードは資産ではなく負債だからです**（p.10）
* 質の良いテスト・ケースだけを集めることに意識を向けなくてはなりません（p.10）
* **網羅率はテスト・スイートの質が悪いことを示せても、テスト・スイートの質が良いことを証明することはできない**（p.11）
* 部分的にしか検証されないテストを極端にしたものが確認不在のテスト（p.16）
  * テスト対象のコードを単に実行するだけで、何も確認していないテストのこと
* **優れたテスト・スイート**（pp.20-21）
  * テストすることが開発サイクルの中に組み込まれている
  * コードベースの特に重要な部分のみがテスト対象となっている
    * 核となる部分は……ドメイン・モデル
    * ドメイン・モデルをコードベースの本質ではない部分から隔離しておかなくてはならない
  * 最小限の保守コストで最大限の価値を生み出すようになっている

---

## 第2章：単体テストとは何か？

* 単体テストの定義（p.28）
  * 「単体（unit）」と呼ばれる少量のコードを検証する
  * 実行時間が短い
  * 隔離された状態で実行される
* **ロンドン学派が考える隔離**（p.29）
  * テスト対象となるクラスが他のクラスに依存しているのであれば、その依存をすべてテスト・ダブルに置き換えなくてはならない
* **古典学派が考える隔離**（pp.37-38）
  * 隔離する必要があるのはコードではなくテスト・ケースであり、各テスト・ケースをお互いに影響を与えることなく個別に実行できるようにしなくてはならない
  * 共有依存、プライベート依存、プロセス外依存
  * テスト・ダブルが使われるのはテスト・ケース間で共有される状態を持つ依存に対してのみです
* ロンドン学派は……依存の種類によってはテスト・ダブルに置き換えずにそのまま使うことを許す場合がある……もし依存が不変（immutable）であれば、その依存はテスト・ダブルに置き換える必要はありません……このような不変オブジェクトは値オブジェクト、もしくは、単に値と呼ばれます（pp.41-42）
* **私個人は古典学派のスタイルのほうを好んでいます**。その理由は、**古典学派のほうがより良質な単体テストを作成でき、単体テストの究極的な目標である、プロジェクトの持続的な成長を促す、ということを達成するのに向いているからです**。このようになるのは、ロンドン学派のスタイルで作成するモックを用いた単体テストは古典学派のスタイルで作成する単体テストよりも壊れやすくなるからです（p.46）
* ロンドン学派の主張に対する反論
  * 細かな粒度による検証（p.47）
    * 単体テストでは、1単位のコード（a unit of code）を検証するのではなく、1単位の振る舞い（a unit of behavior）を検証するようにします……コードの粒度を細かくしようとすることは単体テストにおいてあまり有用ではありません
  * 複雑な依存関係を持つものに対する単体テスト（pp.48-49）
    * 本来考えるべきことは……複雑な依存関係を構築しなくても済むようにするための方法
  * テストが失敗した際、どこに問題があったのかが正確に分かる（p.49）
    * 単体テストを頻繁に実施していれば……どこでバグが発生したのかをすぐに見つけ出せる
* 古典学派の観点で再定義（p.52）
  * **1単位の振る舞い（a unit of behavior）を検証すること**
  * 実行時間が短いこと
  * **他のテスト・ケースから隔離された状態で実行されること**
* E2E（End-to-End）テスト（pp.53-54）
  * 一種の統合テストとして見ることができる
  * UI（User Interface）テスト、GUI（Graphical User Interface）テスト、機能（functional）テストなどと呼ばれることもあります

---

## 第3章：単体テストの構造的解析

* AAAパターン（3Aパターンとも呼ばれる）……では、**テスト・ケースを準備（Arrange）、実行（Act）、確認（Assert）の3つのフェーズで構成します**（p.58）
* 確認（Assert）フェーズで確認する項目はどのくらいあればよいのか？（pp.65-66）
  * 1単位の振る舞いによって複数の結果が生じることはあり得ること
  * とは言え、確認フェーズが大きくなりすぎるのであれば、開発者は危機感を持たなくてはなりません
  * オブジェクトの全フィールドの値を確認しているのであれば、そのようなことをするのではなく、そのオブジェクトが同等であることを確認できる手段を用意するようにします
* **テスト・フィクスチャの準備をテスト・クラスのコンストラクタで行えば……記述するコードの量は劇的に減ることになります**。しかしながら、この方法には、次にあげる**2つの重大な欠点**があります（p.72）
  * テスト・ケース間の結び付きが強くなってしまう
  * テスト・ケースが読みづらくなってしまう
* **共通的に利用するテスト・フィクスチャの準備に関するコードをプライベートなファクトリ・メソッドに定義する**ことで、テスト・コードの量を減らすのと同時に各テスト・ケースで何が行われるかを完全に理解できるようになります（p.75）
* しかしながら、テスト・フィクスチャの準備をコンストラクタで行うことに関して、1つ例外があります。それは、すべてのテスト・ケース（もしくは、ほぼすべてのテスト・ケース）で同じテスト・フィクスチャを使うようになっているのであれば、コンストラクタを使ってもよい、ということです（p.76）
* **単体テストでの名前の付け方**
  * 非常に有名で、おそらく、もっとも役に立たないのが次のような命名規則です（pp.77-78）
    * `{テスト対象メソッド}_{事前条件}_{想定する結果}`
    * 実用性がない理由は、目を向けている部分が振る舞いではなく実装の詳細だからです
    * このようなことをするよりも、簡潔な普通の言い回しにしたほうが何を検証しているのかがより明確になる
    * 非開発者がこのテスト・メソッド名を見ても、このテスト・メソッドが何を検証するものなのかが全く伝わらないはずです
  * テスト・メソッドに名前を付けるときの指針（p.79）
    * **厳格な命名規則に縛られないようにする**
    * **問題領域のことに精通している非開発者に対して、どのような検証をするのかが伝わるような名前を付ける**
    * （英語の場合は）アンダースコア（「_」）を使って単語を区切るようにする
  * 指針に従った名前に変えた場合の例（pp.80-82）
    * `IsDeliveryValid_InvalidDate_ReturnsFalse` → `Delivery_with_invalid_date_should_be_considered_invalid`
    * さらなる改善が可能
      1. `Delivery_with_past_date_should_be_considered_invalid`
      2. `Delivery_with_past_date_should_be_invalid`
      3. `Delivery_with_past_date_is_invalid`
      4. `Delivery_with_a_past_date_is_invalid`
* パラメータ化テストを使うことで、テスト・コードの量を劇的に減らせるようになります。しかしながら、この利点と引き換えに課せられる負担……とは、このテスト・メソッドが何の事実を表現しているのかが分かりづらくなる、ということです。この対応策として、正常系のテスト・ケースのみを独自のテスト・グループとして抜き出す（p.85）

---

## 感想と考察

ここからは本を読みながら、私が思ったことや考えたことを書きます。

### 本を読む前のテストに対する認識

まず前提として、本を読む前の私のテストに対する認識をまとめます。

* 単体テストは普段から書いている
  * Python と [pytest](https://docs.pytest.org/en/7.2.x/) を使用
  * カバレッジは100%にしようというチームのルールがある
  * CI パイプラインに組み込まれている
* モックの使い方にいまいち自信がない
  * 自作自演になっている気がする時がある
* データベースのテストはやるべきか迷う
* ラージテスト・スモールテスト、統合テスト、退行テストなどの用語の正確な意味や使い分けを知らない
* TDD について勉強したことはない

上記のような感じで、あらためて振り返るとテストに関して自分がなんとなくやってきたことがさらけ出されてしまいました。今回の本では、私のようなレベルの読者でも引っかかることなく親切に解説されています。

### 古典学派 vs ロンドン学派

学びは色々とあるのですが、まず知ったのは「古典学派」と「ロンドン学派」がある、ということです。古典学派は[『テスト駆動開発』（Kent Beck 著、和田卓人訳）](https://www.ohmsha.co.jp/book/9784274217883/)を原点としています。ロンドン学派はロンドンのプログラミング・コミュニティで生まれたことに由来しています。ロンドン学派は1単位のコードをテストするために、テスト対象以外の依存はモックを使うようにするべきと考えていて、古典学派は1単位の振る舞いをテストするために、単体テスト同士が状態を共有する依存に対してのみモックを使うべきと考えています。

私の所属するチームでは明確にどちらの学派の主張を採用しているわけではありませんが、どちらかというとロンドン学派に近いように感じました。各メソッドを「1単位のコード」と見て、単体テストを書いています。モックに関してはロンドン学派ほど厳格ではないですが、例えば lib は lib で単体テストを行っているという理由で、lib の呼び出し側に対する単体テストでは lib をモックするというようなケースはしばしばあります。

筆者が指摘する通り、私のコードベースでは1つをリファクタするとそのテストや周辺のテストも直さないといけないので、これは維持コストのかかる良くないテストコードなのかも、ということに気づきました。

### テスト・フィクスチャ

第3章の「テスト・フィクスチャの準備」についての議論も興味深かったです。本の中ではコンストラクタを使って繰り返し同じ記述を書くことを避けることに関して、「テスト・ケースが読みづらくなってしまう」ことに言及しています。

私はテストクラスでコンストラクタを使うことはあまり多くないですが、[pytest.fixture を autouse=True にする](https://docs.pytest.org/en/7.2.x/how-to/fixtures.html#autouse-fixtures-fixtures-you-don-t-have-to-request)ことは多いです。コードの量を削減できる一方で、これも多用しすぎるとテストコードが読みにくくなってしまうので気を付けたいと思いました。

### 命名規則

命名規則に関しては以下のようなルールを設けています。前提として、テスト対象のメソッドに対して、テストクラスを1つ作るルールになっています。下記の命名はそのテストクラスのメソッド名に対するものです。

* 正常系
  * `test_success` もしくは `test_success_{事前条件}`
    * e.g. `test_success_when_hoge_is_fuga`
* 異常系
  * `test_failure_{事前条件}`
    * e.g. `test_failure_when_hoge_is_invalid`

本ではよくある（そして役に立たない）命名規則の例として `{テスト対象メソッド}_{事前条件}_{想定する結果}` というものが挙げられていますが、私のチームでもテスト対象メソッドごとにテストクラスを作っている時点で、想定する結果（success/failure）や事前条件（when～）もあるので、これに該当してしまっていると思いました。

ただ、これに関しては私自身そこまで悪いとは思っていません。ルールがあるといっても、頭に `test_success` `test_failure` をつけているだけですし、この程度ならむしろ見やすくて良いと思います。しかしながら、そもそもこのテストクラスの作り方の枠組み自体が、振る舞いよりもコードの実装に目が行くものなのは確かなので、この点に関しては本の続きを読みながらより良くしていくためにどうするべきかを考えていきたいと思っています。

## まとめ

以上、第1部「単体（unit）テストとは」についてのまとめと所感を拙文ながら書きました。

まだ途中ですが、読みやすく面白い予感なので、気になった方は是非本を手に取って読んでみてください！
